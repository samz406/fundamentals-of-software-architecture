# fundamentals-of-software-architecture 学习笔记

## 目录

1. [第一章](#第一章)
2. [第二章 架构思维](#架构思维)
3. [第三章 模块化](#模块化)
4. [第四章 架构特性定义](#架构特性定义)
5. [分离关注点与职责模型](#分离关注点与职责模型)
6. [隔离层](#隔离层)
7. [添加新层](#添加新层)
8. [反模式和其他考虑因素](#反模式和其他考虑因素)
9. [使用分层架构的理由](#使用分层架构的理由)
10. [架构特性评分](#架构特性评分)
11. [结论](#结论)


## 第一章
<img width="653" alt="image" src="https://github.com/user-attachments/assets/0f8fb6e9-c7a5-4ce3-91cf-01ccf2f8741f">
架构由结构、架构特征、设计原则组成

###### 1. 软件架构定义

结构：系统的结构包括架构风格（如微服务、分层架构等）​​。

架构特性：架构特性是系统必须支持的成功标准，通常与系统功能无关，但对系统正常运行至关重要​​。

架构决策：这些是系统应如何构建的规则。例如，架构师可能会决定在分层架构中，只有业务层和服务层可以访问数据库​​。

设计原则：设计原则是构建系统的指南，而不是硬性规定。例如，在微服务架构中使用异步消息传递以提高性能​​。

###### 2. 架构师的期望
架构师需要具备以下核心能力：

做出架构决策：引导而不是指定技术选择​​。

持续分析架构：确保架构在业务和技术变化中保持活力​​。

紧跟最新趋势：保持对最新技术和行业趋势的了解​​。

确保决策的合规性：确保开发团队遵循架构决策和设计原则​​。

广泛的技术和经验：至少熟悉多种技术​​。

商业领域知识：了解业务领域，以便更有效地设计架构​​。

人际交往能力：具备团队合作、协调和领导能力​​。

理解并驾驭公司政治：能够在企业的政治环境中有效地工作​​。

###### 3. 架构与其他领域的交集

工程实践：包括持续集成、自动化机器配置等​​。

运维/DevOps：架构与运维的紧密结合使得设计更加简化​​。

开发过程：软件开发过程（如敏捷开发）对架构有重要影响​​。

数据：数据架构是软件架构的重要组成部分，涉及如何存储和管理数据​​。

###### 4. 软件架构法则

第一法则：软件架构中的一切都是权衡取舍​​。

第二法则：理解为什么比理解如何更重要​​。


## 第二章 架构思维

##### 1. 架构与设计的区别


<img width="637" alt="image" src="https://github.com/user-attachments/assets/0db69e27-30ee-4a8f-aee1-4539080c12b5">


定义差异：架构和设计的区别常常引起混淆。架构涉及高层次的系统结构和全局决策，而设计关注实现这些结构的细节 。

传统职责分工：架构师负责分析业务需求、选择架构模式和创建系统组件，开发团队则负责具体的类图、用户界面和代码开发 。

协作需求：为了成功，架构师和开发团队必须紧密合作，确保架构设计和实现保持同步 。

#####  2. 技术广度

<img width="641" alt="image" src="https://github.com/user-attachments/assets/13ba8331-6d3b-4cde-bd9c-35da98b20bfe">

- 知识金字塔

技术知识的层次：技术知识可以分为三个层次：已知的知识（即技术深度）、已知的未知（知道自己不知道的知识）和未知的未知（不知道自己不知道的知识）。这三个层次共同构成了知识金字塔 。

已知的知识：指的是一个技术人员在日常工作中使用的技术、框架、语言和工具。例如，一个Java程序员对Java语言的掌握。

已知的未知：指的是技术人员听说过但不熟悉的技术。例如，许多技术人员知道Clojure是一种基于Lisp的编程语言，但可能并不精通。

未知的未知：指的是那些技术人员不知道它们存在，但实际上可能是解决当前问题的最佳方案的技术和工具。

- 技术人员的知识发展

开发人员的早期职业：开发人员在职业生涯的早期通常专注于扩展知识金字塔的顶端，即增加技术深度。这是因为开发人员需要更多的实践经验和操作知识来完成他们的工作 。
技术深度的维护：随着开发人员获得更多的经验，他们需要不断维护和更新他们的技术知识，因为技术在不断发展。例如，一个开发人员如果多年不使用某种技术，那么他们对该技术的掌握程度会逐渐减弱 。

- 架构师的技术广度

技术广度的重要性：架构师需要比开发人员拥有更广泛的技术知识，以便在不同的技术约束和业务需求下做出最佳决策。相比于单一的技术专长，广泛的技术知识更有助于架构师识别和应用最适合的技术解决方案 。

广度优先于深度：架构师应更加注重技术广度而不是深度。这意味着他们需要对多种技术、框架和工具有所了解，而不必精通每一种技术 。

技术广度的培养：架构师可以通过参与不同类型的项目、持续学习新技术和与其他技术专家交流来扩展他们的技术广度 。

- 角色转换中的挑战

从开发人员到架构师的过渡：开发人员在转变为架构师时，通常会面临一个从深度到广度的知识转换过程。这可能是一个具有挑战性的过程，因为这需要他们改变长期以来形成的专注于技术深度的思维模式 。
避免技术过时：架构师需要警惕其技术知识的过时性，即避免陷入“冰冻穴居人反模式”，即架构师依赖于过去的技术知识而忽略了新的技术发展 。

- 实践中的技术广度

技术广度的实际应用：在实际工作中，架构师需要广泛的技术知识来解决复杂的技术问题。例如，在选择缓存解决方案时，了解多种缓存产品及其优缺点会比只精通一种产品更有价值 。

##### 3. 权衡分析

不可避免的权衡：架构决策总是伴随着权衡，无法通过简单的搜索得到答案。每个架构问题的答案都依赖于具体的环境和需求 。
实例分析：例如，在竞拍系统中，选择使用队列还是主题进行消息传递，架构师需要根据具体情况分析两者的优缺点 。

##### 4. 理解业务驱动因素

业务需求转换：架构师需要将业务需求转化为架构特性（如可扩展性、性能和可用性），这需要对业务领域的深入理解和与业务利益相关者的紧密合作 。

##### 5. 平衡架构与实践编码

保持技术深度：架构师应保持一定的编码实践，以避免成为团队的瓶颈。通过参与实际项目中的代码开发，可以更好地理解团队面临的挑战 。
避免瓶颈陷阱：架构师不应过多参与关键路径的编码工作，而是应将这些任务分配给开发团队，以防止自己成为项目的瓶颈 。

ps: 没有完美架构，都是trade off


## 第三章 模块化


##### 定义

模块化在软件架构中是一个核心概念，但其定义常常混乱且不统一。一般来说，模块化是指将相关代码逻辑分组的方法，这可以是面向对象语言中的类组，或结构化或函数式语言中的函数组​​。大多数编程语言提供了某种模块化机制，如Java中的包（package）和.NET中的命名空间（namespace）。

##### 模块化的意义

模块化是组织代码的一种原则，目的是通过逻辑分组来管理代码的复杂性。如果架构师在设计系统时不关注各个部分的相互连接方式，就会导致系统难以维护和扩展​​。模块化有助于保持系统结构的有序性和一致性，即使在项目需求中没有明确要求，也需要架构师主动确保模块间的良好区分和沟通。

##### 模块化复用

在面向对象编程之前，开发者使用模块化语言来组织代码，例如Modula和Ada。这些语言提供了类似于今天的包或命名空间的编程结构，用于逻辑分组相关代码​​。尽管面向对象语言引入了类和继承等新概念，模块化的思想仍然保留了下来。

##### 度量模块化

架构师需要工具来理解和度量模块化。关键概念包括内聚性、耦合性和共生性​​。

###### 内聚性

内聚性衡量模块内各部分的相关程度。高内聚性意味着模块的各部分紧密相关，所有部分应包含在同一模块内。例如，功能内聚的模块中，每个部分都与其他部分相关，并且模块包含完成其功能所需的一切​​。

内聚性是指模块内部各部分之间的紧密程度，它衡量的是模块内的元素在一起工作的合理性和相关性。高内聚性意味着模块内的各个元素密切相关，共同实现一个明确的功能或目标。内聚性是评估模块化设计质量的重要标准之一，因为高内聚性通常表示模块更容易理解、维护和复用。

内聚性的类型

内聚性从高到低可以分为以下几种类型：

- 功能内聚（Functional Cohesion）


定义：模块内的所有元素共同完成单一功能。

示例：一个模块负责处理用户登录验证，包括接收用户输入、验证用户名和密码、返回验证结果。

特点：这种内聚性最高，模块内的所有元素都与完成该功能密切相关，任何对功能的更改都在模块内完成。

- 顺序内聚（Sequential Cohesion）

定义：模块内的元素按顺序执行，每个元素的输出作为下一个元素的输入。

示例：一个模块首先读取文件数据，然后处理数据，最后将结果写入数据库。

特点：元素之间存在顺序依赖关系，功能较为集中，但各部分之间的联系较强。

- 通信内聚（Communicational Cohesion）


定义：模块内的元素操作同一数据集合。

示例：一个模块负责从数据库中读取数据、处理数据并生成报告。

特点：元素通过共享数据联系在一起，数据变化可能会影响多个元素。

- 过程内聚（Procedural Cohesion）

定义：模块内的元素必须按特定顺序执行，但不一定操作相同的数据。

示例：一个模块包括一系列用户界面操作步骤，如显示登录页面、接收输入、验证用户。

特点：步骤之间有顺序依赖，但数据和功能之间的关联性较低。

- 时间内聚（Temporal Cohesion）

定义：模块内的元素在同一时间段执行。

示例：一个初始化模块负责在系统启动时执行多个初始化任务，如加载配置文件、建立数据库连接。

特点：元素仅在时间上相关，功能上可能毫无关联。

- 逻辑内聚（Logical Cohesion）

定义：模块内的元素执行逻辑上相似的任务，但实际上可以独立完成。

示例：一个输入输出模块包含读取文件、读取数据库、读取网络数据等功能。

特点：元素之间逻辑相关，但彼此独立，内聚性较低。

- 偶然内聚（Coincidental Cohesion）

定义：模块内的元素没有任何明显的关系，只是偶然被放在一起。

示例：一个模块包含各种杂乱无章的功能，如日志记录、数据转换、用户通知等。

特点：这种内聚性最低，模块内的元素彼此独立，维护困难，修改时容易引入错误。

内聚性的影响

可维护性：高内聚性的模块更容易理解和修改，因为所有相关功能都集中在一起。维护高内聚性模块时，开发者可以集中关注该模块的特定功能，而不必担心其他不相关的部分。
复用性：高内聚性的模块更容易复用，因为其功能明确且独立。一个功能内聚的模块可以在不同项目或系统中被直接使用，而无需做大量修改。
测试性：高内聚性的模块更容易测试，因为其功能集中，测试覆盖率更高。测试一个高内聚性的模块通常只需要考虑模块内部的逻辑，而不必处理大量的外部依赖。
灵活性：高内聚性的模块在系统中更灵活，可以更容易地进行重构和扩展。因为其内部元素紧密相关，更改或扩展一个功能通常只影响该模块内部，而不会波及到其他模块。
实现高内聚性的方法
单一职责原则（Single Responsibility Principle, SRP）

定义：一个模块只负责一个功能或职责。
应用：确保每个模块只包含实现该功能所需的代码，避免将无关的功能混杂在一起。
模块化设计

定义：将系统划分为多个独立的模块，每个模块都有明确的职责和功能。
应用：根据功能将代码分组，确保每个模块内部的功能紧密相关，模块之间的依赖最小化。
重构

定义：通过调整代码结构来提高内聚性和降低耦合性。


###### 耦合性

耦合性衡量模块之间的相互依赖程度。较低的耦合性意味着模块间依赖较少，模块可以更独立地变化。Edward Yourdon和Larry Constantine在1979年定义了两个关键耦合性指标：传入耦合（afferent coupling）和传出耦合（efferent coupling）​​。

抽象度、稳定性和主序列距离（Abstractness, Instability, and Distance from the Main Sequence）
Robert Martin定义了一些派生度量来深入评估模块化，其中包括抽象度、稳定性和主序列距离​​。

抽象度（Abstractness）：抽象工件（如抽象类和接口）与具体工件（如实现类）的比率。
稳定性（Instability）：传出耦合与传入和传出耦合之和的比率。
公式如下：


在这些公式中，ma代表抽象元素，mc代表具体元素，Ce代表传出耦合，Ca代表传入耦合。主序列距离（Distance from the Main Sequence）衡量抽象度与稳定性之间的理想关系，类的位置越接近理想线，类的平衡性越好​​。

###### 共生性

Meilir Page-Jones在1996年提出了共生性的概念，用于描述软件系统中两个组件之间的依赖关系。**当一个组件的变化需要另一个组件也做出相应变化以保持系统的正确性时，这两个组件被称为共生性​​**。

共生性分为两种类型：

静态共生性: 

  是指源代码级的耦合，它是对Structured Design中定义的传入耦合和传出耦合的细化，架构师将以下静态共生性的类型视作事物之间相互耦合的程度，无论它们是传入耦合还是传出耦合：包含如下类型：

- 名称共生性

定义：多个组件必须使用相同的名称来引用某个实体。
示例：方法名是代码库中最常见的耦合方式，尤其是在现代重构工具可以轻松地进行系统范围内的名称更改时​​。

- 类型共生性

定义：多个组件必须同意实体的类型。
示例：这类共生性在许多静态类型语言中很常见，通过类型检查来限制变量和参数的类型​​。
意义共生性

定义：多个组件必须同意特定值的意义。
示例：代码库中硬编码的数值是最常见的例子，如定义 int TRUE = 1; int FALSE = 0;​​。
位置共生性

定义：多个组件必须同意值的顺序。
示例：方法和函数调用中的参数值顺序问题​​。

算法共生性

定义：多个组件必须同意使用特定的算法。
示例：安全哈希算法必须在服务器和客户端上生成相同的结果以进行用户验证​​。

动态共生性: 分析运行时调用


- 执行顺序共生性

定义：多个组件的执行顺序是重要的。

示例：电子邮件发送顺序：必须先设置收件人和发件人，然后才能发送邮件​​。

- 时间共生性

定义：多个组件的执行时间是重要的。

示例：两个线程同时执行可能会导致竞态条件，从而影响联合操作的结果​​。

- 值共生性

定义：多个值之间存在依赖关系，必须一起更改。

示例：分布式系统中的事务处理，所有值必须一起更改，否则不能更改​​。

- 身份共生性

定义：多个组件必须引用相同的实体。

示例：独立组件共享和更新公共数据结构，如分布式队列​​


###### 共生性的属性

强度（Strength）：强度决定了重构的难易程度。架构师应优先考虑强度较低的共生性，因为它们更容易重构​​。
局部性（Locality）：共生性的局部性衡量模块之间的接近程度。同一模块内的强共生性比跨模块的强共生性对代码库的影响更小​​。
程度（Degree）：共生性的程度与其影响范围有关。影响范围较小的共生性对代码库的破坏较小​​。
Jim Weirich提出了两条关于共生性的重要建议：

程度规则：将强共生性转换为弱共生性。

局部性规则：随着软件元素之间距离的增加，使用更弱的共生性形式​​。

Page-Jones提供了三种通过共生性来提升系统模块化的准则:

1.将系统分解为封装元素来最小化整体共生性

2.最小化跨越封装边界的任何剩余共生性

3.最大化封装边界内的共生性


###### 统一耦合和共生性指标
<img width="712" alt="image" src="https://github.com/user-attachments/assets/90967ddb-0542-4e18-ab6a-ff2ab39eee0f">


##### 从模块到组件

架构师通常从组件的角度来思考系统。组件是模块的物理实现形式，开发者可以以不同的方式打包组件，具体取决于其开发平台。例如，Java中的jar文件、.NET中的dll文件等​​。

组件构成了架构中的基本模块化构建块，是架构师必须关注的关键内容之一。架构师的主要任务之一是确定组件的顶级划分​​。



## 第四章 架构特性定义


### 架构特性的定义标准

一个架构特性需要满足以下三个标准：

非领域设计考虑因素：架构特性描述了如何实现系统需求及其原因，而不仅仅是系统应做什么。例如，性能通常不会出现在需求文档中，但它是一个重要的架构特性 。

影响设计的某些结构方面：架构特性往往需要特定的结构考虑。例如，安全性是大多数项目的关注点，如果系统需要处理支付处理，架构可能需要设计一个特定的模块来处理这些敏感信息 。

对应用成功至关重要：支持每个架构特性会增加设计的复杂性，因此架构师需要选择最少的架构特性，而不是尽可能多 。

### 架构特性的分类

#### 操作性架构特性

操作性架构特性涵盖了系统在运行时必须具备的能力，如性能、可扩展性、弹性、可用性和可靠性。以下是一些常见的操作性架构特性 ：

可用性：系统需要多长时间可用。

连续性：灾难恢复能力。

性能：包括压力测试、峰值分析、功能使用频率分析、所需容量和响应时间。

可恢复性：灾难发生后系统需要多快恢复在线。

可靠性/安全性（Reliability/Safety）：评估系统是否需要故障安全或任务关键。

鲁棒性（Robustness）：在运行过程中处理错误和边界条件的能力。

可扩展性（Scalability）：系统在用户数量或请求增加时的性能和操作能力。

#### 结构性架构特性

结构性架构特性关注代码结构和质量，如良好的模块化、受控的组件之间的耦合、可读代码等。以下是一些常见的结构性架构特性 ：

可配置性（Configurability）：终端用户通过可用界面轻松更改软件配置的能力。

可扩展性（Extensibility）：添加新功能的难易程度。

可安装性（Installability）：系统在所有必要平台上的安装难易程度。

杠杆性/复用性（Leverageability/Reuse）：在多个产品中复用通用组件的能力。

本地化（Localization）：支持多语言输入/查询屏幕、数据字段、报告等。

可维护性（Maintainability）：应用更改和增强系统的难易程度。

可移植性（Portability）：系统是否需要在多个平台上运行。

支持性（Supportability）：应用所需的技术支持级别。

可升级性（Upgradeability）：从旧版本升级到新版本的难易程度。

#### 跨领域架构特性（Cross-Cutting Architecture Characteristics）

某些架构特性难以归类，但它们仍然是重要的设计约束和考虑因素。以下是一些常见的跨领域架构特性 ：

可访问性（Accessibility）：包括色盲、听力障碍等残疾用户的访问。

可归档性（Archivability）：数据是否需要归档或在一段时间后删除。

认证（Authentication）：确保用户身份的安全要求。

授权（Authorization）：确保用户只能访问应用的某些功能的安全要求。

法律合规性：系统运营中涉及的立法约束。

隐私：对内部公司员工隐藏事务的能力。

安全性：数据在数据库中的加密需求、内部系统之间网络通信的加密需求等。

可支持性：应用所需的技术支持级别和调试系统错误所需的日志记录设施。

可用性/可达成性：用户通过应用达到目标所需的培训级别。

#### 架构特性之间的权衡

应用程序通常只能支持我们列出的少数几个架构特性，原因多种多样。首先，每一个支持的特性都需要设计上的努力，甚至可能需要结构上的支持。其次，更大的问题在于，每个架构特性往往会影响到其他特性。例如，如果架构师想要提高安全性，几乎肯定会对性能产生负面影响：应用程序必须进行更多的实时加密、秘密隐藏的间接处理以及其他可能降低性能的活动。

一个比喻可以帮助说明这种互联性。据说飞行员在学习驾驶直升机时经常会遇到困难，因为驾驶直升机需要每只手和每只脚都控制一个操纵杆，改变一个操纵杆会影响到其他操纵杆。因此，驾驶直升机是一种平衡的练习，这很好地描述了选择架构特性时的权衡过程。每个架构师设计支持的架构特性都有可能使整体设计变得复杂。

因此，架构师很少遇到能够设计一个系统并最大化每个架构特性的情况。更多的时候，**决策是几种相互竞争的关注点之间的权衡**

#### 设计“最不差”架构

总之，架构师很少能设计出在每个方面都最佳的系统。通常，决策涉及多个相互竞争的关注点之间的权衡 。架构师应尽量设计可迭代的架构，这样可以更容易地对架构进行更改，从而减少复杂性和风险 。


## 第五章：识别架构特性


识别关键的架构特性是创建架构或确定现有架构有效性的重要步骤。要识别适用于特定问题或应用的正确架构特性（“-ilities”），架构师不仅需要了解领域问题，还需要与问题域的利益相关者合作，以确定从领域角度看什么是真正重要的 。

### 从领域关注点中提取架构特性

架构师必须能够将领域关注点转化为架构特性。例如，扩展性是最重要的关注点，还是容错性、安全性或性能？也许系统需要所有这四个特性。了解关键的领域目标和领域情况可以让架构师将这些领域关注点转化为“-ilities”，从而形成正确且合理的架构决策的基础 。

在与领域利益相关者合作定义驱动架构特性时，一个提示是尽量保持最终列表尽可能简短。架构中的一个常见反模式是试图设计一个通用架构，支持所有架构特性。每个支持的架构特性都会增加系统设计的复杂性；支持太多的架构特性会在架构师和开发人员还没有开始解决问题域时就导致复杂性大大增加。因此，不要过分关注特性的数量，而要关注保持设计简单的动机 。

案例研究：Vasa战舰

Vasa战舰是过度规定架构特性最终导致项目失败的经典例子。这是一艘瑞典战舰，建造于1626年至1628年间，由希望建造最宏伟战舰的国王下令建造。当时的船只通常是运兵船或战舰，而Vasa战舰要同时具备这两种功能。大多数船只有一层甲板，而Vasa战舰有两层！尽管经验丰富的造船工匠有些担忧，但最终还是完成了建造。在庆祝时，战舰驶入港口并向一侧发射了炮弹。由于战舰重心过高，最终倾覆并沉入瑞典湾底。这个故事告诉我们，过度规定架构特性会导致设计复杂性和风险增加，最终可能导致项目失败 。

### 从需求中提取架构特性


#### 从需求中提取架构特性

从需求中提取架构特性需要架构师深入理解需求文档并识别出其中的架构特性。架构师必须将需求翻译成架构特性，以确保系统满足这些需求。例如，一个购物网站可能希望支持特定数量的并发用户，这是需求文档中明确规定的。架构师需要将这种需求转化为扩展性特性，以确保系统能够处理大量并发用户而不会出现性能问题 。

#### 隐含特性

隐含特性是指那些没有明确写在需求文档中的特性，但它们对系统的成功至关重要。例如，安全性可能不会在需求文档中明确指出，但对于处理支付信息的系统来说，安全性是不可或缺的 。

案例研究：硅三明治

为了更好地说明这些概念，书中引入了一个架构Kata——硅三明治（Silicon Sandwiches）。这个案例研究展示了架构师如何从需求中提取架构特性 。

描述：一家全国性的三明治店希望实现在线订购（除了现有的电话订购服务）。

用户：成千上万，可能有一天会有数百万用户。

需求：

用户下订单后，将获得一个取餐时间和商店的方向（需要集成多个外部地图服务，包括交通信息）。

如果商店提供送餐服务，调度司机将三明治送到用户手中。

移动设备可访问性。

提供全国每日促销/特价。

提供本地每日促销/特价。

接受在线支付、现场支付或送餐支付 。

附加背景：

三明治店是特许经营店，每家店都有不同的店主。
总公司计划在不久的将来扩展到海外。
公司目标是雇佣廉价劳动力以最大化利润 。
在这个场景中，架构师如何提取架构特性呢？架构师不会在这里设计整个系统，而是寻找那些影响或影响设计的因素，特别是结构性的因素 。

#### 显式特性

显式架构特性出现在需求规范中，作为必要设计的一部分。例如，一个购物网站可能希望支持特定数量的并发用户，这在需求规范中由领域分析师指定。架构师需要考虑需求的每一部分，看看它是否构成架构特性 。

一个架构师首先应该注意到的细节是用户数量：目前是成千上万，可能有一天会达到数百万。因此，扩展性——处理大量并发用户而不会严重性能下降的能力——是顶级架构特性之一。注意，这个问题陈述并没有明确要求扩展性，而是以预期用户数量的形式表达了这一需求。架构师经常需要将领域语言解码为工程等价物 。


## 第六章 度量和管理架构特性

### 度量架构特性

组织中存在几个关于架构特性定义的常见问题：

它们不是物理学：许多常用的架构特性含义模糊。例如，架构师如何设计敏捷性或可部署性？行业对这些常见术语的定义存在巨大差异，有时是由于不同的上下文，有时是偶然的​​。

定义变化大：即使在同一个组织内，不同部门对关键特性的定义也可能存在分歧。除非开发人员、架构师和运维部门统一定义，否则很难进行有效的对话​​。

过于复合：许多理想的架构特性在较小的尺度上包含了许多其他特性。例如，开发人员可以将敏捷性分解为模块化、可部署性和可测试性​​。

通过组织范围内达成架构特性的具体定义，团队可以围绕架构创建通用语言。同时，通过鼓励具体定义，团队可以解开复合特性，揭示可以客观定义的可测量特性​​。

#### 操作性度量

许多架构特性具有明显的直接测量方法，如性能或可扩展性。然而，即使是这些也提供了许多细微的解释，取决于团队的目标。例如，团队可能会测量某些请求的平均响应时间，这是操作性架构特性的一个很好的例子。但如果团队只测量平均值，如果某个边界条件导致1%的请求花费比其他请求长10倍的时间会怎样？如果站点的流量足够多，这些异常值可能根本不会出现。因此，团队可能还希望测量最大响应时间以捕捉异常值​​。

性能的多种形式

我们描述的许多架构特性有多种细微的定义。性能就是一个很好的例子。许多项目关注一般性能：例如，网络应用程序的请求和响应周期需要多长时间。然而，架构师和DevOps工程师在建立性能预算方面做了大量工作：为应用程序的特定部分制定具体的预算。例如，许多组织研究了用户行为，确定了首次页面渲染（在浏览器或移动设备中网页的第一个可见进度标志）的最佳时间是500毫秒（半秒）；大多数应用程序在这个指标上落在两位数范围内。但对于试图捕获尽可能多用户的现代站点来说，这是一个重要的指标，这些组织已经建立了非常细致的度量标准​​。

这些指标中的一些对应用程序的设计有额外的影响。许多前瞻性组织为页面下载设定了K-weight预算：特定页面上允许的库和框架的最大字节数。他们这样做的理由源于物理限制：一次只能通过网络传输一定数量的字节，特别是对于高延迟区域的移动设备​​。

高级团队不仅设定了严格的性能数字；他们基于统计分析建立了定义。例如，假设一个视频流服务想要监控可扩展性。工程师不是设置一个任意数字作为目标，而是测量随时间变化的规模，并建立统计模型，然后如果实时指标超出预测模型就会发出警报。故障可能意味着两件事：模型不正确（团队希望知道）或有问题（团队也希望知道）​​。

####  结构性度量

一些客观度量不如性能那么明显。内部结构特性如良好定义的模块化怎么办？不幸的是，目前还没有全面的内部代码质量度量标准。然而，一些度量和常用工具确实允许架构师解决代码结构的一些关键方面，尽管是沿着狭窄的维度​​。

##### 圈复杂度

圈复杂度（CC）是由Thomas McCabe Sr.于1976年开发的代码级度量，旨在为代码复杂性提供一个客观的度量标准​​。

它是通过将图论应用于代码，特别是决策点，从而导致不同的执行路径来计算的。例如，如果一个函数没有决策语句（如if语句），那么CC=1。如果该函数有一个条件语句，则CC=2，因为存在两种可能的执行路径​​。

计算单个函数或方法的CC公式为CC = E − N + 2，其中N代表节点（代码行），E代表边（可能的决策）​​。

#### 过程度量

一些架构特性与软件开发过程交叉。例如，敏捷性经常被视为一个理想的特性。然而，它是一个复合的架构特性，架构师可以将其分解为特性如可测试性和可部署性​​。

可测试性可以通过几乎所有平台的代码覆盖工具进行测量，这些工具评估测试的完整性。像所有软件检查一样，它不能取代思考和意图。例如，代码库可能有100%的代码覆盖率，但如果断言质量差，实际上并不能提供代码正确性的信心。然而，可测试性显然是一个客观可测量的特性。同样，团队可以通过各种度量来测量可部署性：成功部署与失败部署的比例、部署花费的时间、部署引发的问题/错误等​​。

##### 治理和适应性函数

一旦架构师确定了架构特性并对其进行优先排序，他们如何确保开发人员会遵守这些优先事项？模块化是架构的一个很好的例子，它很重要但不是紧急的；在许多软件项目中，紧迫性占据主导地位，但架构师仍然需要一个治理机制​​。

##### 治理架构特性

治理，源于希腊词kubérnan（掌舵），是架构师角色的重要职责。顾名思义，架构治理的范围涵盖架构师（包括企业架构师）希望影响的软件开发过程的任何方面。例如，确保组织内的软件质量属于架构治理的范畴，因为它属于架构的范围，疏忽可能导致灾难性的质量问题​​。

幸运的是，越来越多复杂的解决方案存在，以缓解架构师的这一问题，这是软件开发生态系统中能力逐步增长的一个很好的例子。极限编程推动的软件项目自动化催生了持续集成，进一步自动化到运维，我们现在称之为DevOps，并延续到架构治理​​。

##### 适应性函数

“进化”一词在《构建进化架构》一书中更多地源于进化计算而非生物学。作者之一，Rebecca Parsons博士，在进化计算领域工作了一段时间，包括使用遗传算法的工具。遗传算法执行并产生一个答案，然后通过进化计算领域定义的知名技术进行变异。如果开发人员试图设计一个遗传算法来产生一些有益的结果，他们通常希望引导算法，提供一个客观的度量来指示结果的质量。这个指导机制被称为适应性函数：一个用于评估结果接近目标程度的对象函数。例如，假设开发人员需要解决旅行推销员问题，这是一个著名的机器学习问题。给定一个推销员和他们必须访问的一系列城市，以及城市之间的距离，什么是最优路径？如果开发人员设计一个遗传算法来解决这个问题，一个适应性函数可能会评估路径的长度，因为最短的路径表示最高的成功。另一个适应性函数可能是评估路径的总成本，并尝试将成本保持在最低水平。还有一个可能是评估旅行推销员的总旅行时间，并优化以缩短总旅行时间​​。


用途

健壮函数不仅限于新框架，而是提供了一个新的视角来使用许多现有工具。健壮函数可以作为指标、监控器、单元测试库、混沌工程等来使用 。例如，架构师可以通过健壮函数来评估页面加载时间，这是架构的一个重要特征。为了允许系统在不降低性能的情况下进行更改，架构可以构建一个健壮函数作为测试，每次页面加载时测量其时间，并在项目的持续集成中运行测试。

Netflix的混沌猴子和灵长类军队

Netflix的混沌工程是健壮函数的一个有趣例子。他们创建了混沌猴子来模拟生产环境中的一般混乱，以查看系统能否承受这些情况。例如，Conformity Monkey允许Netflix架构师定义治理规则并在生产中执行这些规则。如果架构师决定每个服务应该对所有RESTful动词作出有用的响应，他们会将这一检查构建到Conformity Monkey中。类似地，Security Monkey检查每个服务是否存在已知的安全缺陷，而Janitor Monkey查找不再有其他服务路由到的实例，并将其从生产中移除​​。


## 第七章：架构特性范围

### 耦合和共生性

#### 耦合 

是指系统中各个模块或组件之间的依赖程度。高耦合会导致系统的可维护性和灵活性下降，因为一个模块的变化可能会影响其他模块。为了减少耦合，架构师需要设计模块化的系统，使得各个模块尽可能独立。

#### 共生性
是另一种描述系统中组件间依赖关系的方式。共生性分为静态共生性和动态共生性，静态共生性包括名称共生性和类型共生性等，而动态共生性包括执行顺序共生性和时间共生性等。通过分析共生性，架构师可以识别并减少系统中的强依赖关系，从而提高系统的灵活性和可维护性 。

#### 架构量子和粒度

##### 架构量子

是定义系统中独立可部署单元的一种方法。每个架构量子包含实现某个功能所需的所有组件，并且这些组件之间具有强耦合关系。通过识别和定义架构量子，架构师可以更好地管理系统的**复杂性和演变过程** 。

##### 粒度

**是指系统中模块或组件的大小和细化程度**。粒度过大可能导致模块内部复杂性增加，而粒度过小则可能导致模块之间的依赖关系复杂化。架构师需要在系统设计中找到适当的粒度，以平衡模块的独立性和系统的整体复杂性 。

案例研究：竞拍系统“Going, Going, Gone”
为了更好地说明架构量子和粒度的应用，书中引入了一个竞拍系统的案例研究。通过分析和定义竞拍系统中的架构量子，架构师能够确定不同功能模块的边界，减少模块间的耦合，确保系统的可扩展性和维护性 。

在这个案例中，架构师识别了几个关键的架构量子，包括支付服务、竞拍者、出价流和出价跟踪器等。通过使用架构量子分析，架构师能够更容易地确定服务、数据和通信的边界，从而设计出最不差的解决方案 。

#### 确定架构特性范围的方法

识别关键架构特性：架构师需要确定哪些架构特性对系统成功至关重要。例如，性能、可扩展性、安全性等特性在不同系统中可能具有不同的重要性 。

定义架构量子：通过识别系统中的架构量子，架构师可以确定每个独立可部署单元的边界。这有助于减少模块间的耦合，提高系统的灵活性和可维护性 。

确定适当的粒度：在系统设计中找到适当的粒度，以平衡模块的独立性和系统的整体复杂性。过大的粒度可能导致模块内部复杂性增加，而过小的粒度则可能导致模块之间的依赖关系复杂化 。


## 第八章：基于组件的思维

### 组件范围

组件是物理封装模块的实现方式。大多数编程语言支持物理封装，例如Java中的jar文件、.NET中的dll文件和Ruby中的gem文件。在架构中，组件形成了模块化设计的基础，成为架构师必须关注的关键内容之一 。

### 组件的类型

组件可以以多种形式出现，如子系统或架构中的层，事件处理器的可部署单元等。另一种类型的组件是服务，它通常运行在自己的地址空间中，通过低级别的网络协议（如TCP/IP）或高级别的格式（如REST或消息队列）进行通信，形成独立的、可部署的单元，如微服务架构 。

组件提供了一种高于编程语言最低级别的模块化机制。例如，在微服务架构中，服务可能包含足够多的代码以至于需要组件，或者可能简单到只包含少量代码 。

### 架构师的角色

架构师通常在架构中定义、改进、管理和治理组件。软件架构师需要与业务分析师、主题专家、开发人员、QA工程师、运维人员和企业架构师合作，创建软件的初步设计，涵盖架构特性和系统需求 。

架构独立于开发过程存在，这意味着无论采用何种软件开发过程，架构都应存在并发挥作用。尽管某些工程实践（如敏捷软件开发）对架构产生了影响，但总体上，软件架构独立于开发过程 。

### 架构划分

软件架构的第一定律指出，软件中的一切都是权衡，包括架构师在架构中创建组件的方式。组件代表了一种通用的容器机制，架构师可以构建任何类型的划分。常见的架构风格包括技术划分和域划分 。

不同架构模式之间的一个根本区别是它们各自支持的顶级划分风格不同。 它还对架构师如何识别原始组件产生了巨大的影响— —架构师是想从技术上划分还是按领域划分？
使用技术划分的架构师将架构划分为展示层、 业务规则层、 服务层、 持久层等。 因此，此架构的组织原则之一是技术关注点分离。 这进而创建了解耦级别：如果服务层只连接到下面的持久层和上面的业务规则层，那么持久层中.的更改只会潜在地影响这些层。 这种风格的划分提供了一种解耦技巧，减少了对相关组件的连锁副作用。 第10章的分层架构模式中详细介绍这种架构风格。 使用技术划分来组织系统当然是合乎逻辑的，但是，就像软件架构中的所有东西一样，这里有一些权衡。

#### 技术划分

在技术划分中，系统的组件按技术能力组织，如表示层、业务规则、持久层等。这种划分方式使得代码库的组织更为清晰，开发人员可以快速找到与技术能力相关的代码。例如，分层架构就是一种常见的技术划分方式 。

优点

-清晰地分离定制代码。
-更接近分层架构模式。

缺点

- 更高程度的全局耦合。 对通用组件或本地组件的更改可能会影响所有其他组件。

- 开发人员可能不得不在通用层和本地层中重复引入领域概念。

- 通常在数据级有更高的耦合。 在这样的系统中，应用程序架构师和数据架构师可能会协作创建单个数据库，该数据库包含定制化需求的数据和领域数据。 如果架
构师日后想要将此架构迁移到分布式系统中，那么这反过来又会给数据关系的分解带来困难

#### 域划分

域划分基于域驱动设计（Domain-Driven Design, DDD），将架构划分为独立且解耦的域或工作流。每个域组件可能包含子组件，包括层，但顶层划分围绕域进行，更好地反映了项目中最常发生的变化类型。例如，微服务架构就是基于这种哲学的 。

优点：

- 更接近于业务功能而不是实现细节的建模。

- 更容易利用逆向康威演习来围绕领域构建跨功能团队。

- 更接近模块单体和微服务架构风格。

- 消息流匹配问题域。
  
- 易于将数据和组件迁移到分布式架构中。

缺点：


- 定制化代码出现在多个地方

### 开发人员角色

#### 组件识别流

识别组件是架构师在新项目中必须完成的首要任务之一。为了识别组件，架构师需要了解如何划分架构。通常，组件是架构师直接交互的最低级别的软件系统 。组件识别流程包括以下步骤：

识别初始组件：确定系统中需要的初始组件。

分配需求到组件：将系统需求分配给相应的组件。

分析角色和职责：分析每个组件的角色和职责。

分析架构特性：确保每个组件都满足其相关的架构特性。

重构组件：根据需求和特性对组件进行重构，以优化系统设计 。

### 组件粒度（Component Granularity）

组件的粒度是指其大小和细化程度。粒度过大可能导致组件内部复杂性增加，而粒度过小则可能导致组件之间的依赖关系复杂化。架构师需要在系统设计中找到适当的粒度，以
平衡组件的独立性和系统的整体复杂性 。

### 组件设计（Component Design）

组件设计包括确定每个组件的具体实现细节。架构师需要考虑组件的接口、依赖关系、通信方式等，确保每个组件都能够独立运行并与其他组件有效协作 。架构师通常与其他角色（如开发人员、 业务分析人员和主题专家）协作，基于系统的一般知识以及架构划分方式（基于技术或领域划分）来设计初始组件。 团队的目标是进行初步设计，将问题空间划分为考虑不同架构特征的粗块。

#### 发现组件

##### 实体陷阱

##### 演员/动作方法

演员/动作（actor/actions）方法是架构师用于将需求映射到组件的流行方法，最初由IBM旗下的Rational公司开发的统一软件开发过程（Rational Unified Process）定义。 在这种方法中，架构师确定了使用应用程序执行活动的参与者，以及这些参与者可能执行的操作。 它提供了一种技术，用于发现系统的典型用户以及他们可能使用系统做什么。演员/动作方法与特定的软件开发过程（特别是有利于前期设计的正式过程）结合后流行开来。 它仍然很流行，并且当需求具有不同的角色和可以执行的各种操作时工作得很好。这种类型的组件分解风格适用于所有类型的系统，不管是单体系统还是分布式系统。


##### 事件风暴

事件风暴作为一种组件发现技术，来自领域驱动设计。 它与微服务一样受欢迎，也深受领域驱动设计的影响。 在事件风暴中，架构师假定项目将使用消息或事件在各个组件之
间进行通信。 为此，团队尝试根据需求和识别出的角色确定系统中发生的事件，并围绕这些事件和消息处理程序构建组件。 这在使用事件和消息的分布式架构（如微服务）中
很有效，因为它帮助架构师定义最终系统中使用的消息



##### 工作流方法

该方法是事件风暴的另一种替代方法，为不使用领域驱动设计或消息传递的架构师提供了更通用的方法。 工作流方法围绕工作流进行建模，非常类似于事件风暴，但是这种方
法没有用于构建基于消息的系统的显式约束。 工作流方法识别关键角色，确定这些角色参与的工作流类型，并围绕识别的活动构建组件。



## 第九章 基础

### 架构样式的定义与重要性

架构样式（architecture styles）或称架构模式（architecture patterns），指的是组件之间的一种命名关系，涵盖了各种架构特性。架构样式的命名类似于设计模式，它们为有经验的架构师提供了简明的交流方式。例如，当谈到分层单体架构（layered monolith）时，讨论的对象就能立即理解其结构特征、适用的架构特性、典型的部署模型、数据策略等信息。因此，架构师应熟悉这些基础的通用架构样式的名称及其背后的详细信息 。

### 基本模式

基础模式是指在软件架构历史上反复出现的一些基本组织代码、部署或其他架构方面的模式。这些模式不仅有助于理解更复杂的现代架构，还在不同的架构风格中反复出现。

- Big Ball of Mud（混乱的大球）：
- 
这是指缺乏任何可辨别的架构结构的系统，其代码结构混乱无序，缺乏模块化和组织性，导致维护和扩展极其困难。这样的系统常见于初期开发过程中未被明确架构定义的项目 。

- Unitary Architecture（单一架构）：
  
  这种架构通常出现在早期的计算机软件中，当时软件和硬件高度集成。随着计算能力的提高，系统开始分离出不同的功能，例如从单体系统发展到数据库系统的分离。这种架构现今已较少出现，主要存在于嵌入式系统等高度受限的环境中 。
  

- Client/Server（客户机/服务器）：
  
这是一种将系统技术功能划分为前端和后端的架构模式。最常见的变种包括桌面应用程序+数据库服务器、浏览器+网络服务器等。这种模式的一个扩展是三层架构，它进一步将系统划分为用户界面层、业务逻辑层和数据库层 。

- 单体架构与分布式架构

架构样式可以大致分为单体和分布式两类。单体架构通常是单个可部署单元的所有代码，而分布式架构则涉及多个部署单元通过远程访问协议连接 。

### 单体架构包括：

- 分层架构：

是一种非常常见的架构风格，因其简单、熟悉和成本低廉而成为多数应用程序的默认选择。这种架构的组件组织成逻辑层，每一层执行特定的功能，如展示逻辑、业务逻辑、持久层等 。
- 管道架构：

主要用于数据处理流程明确且依赖链条清晰的场景 。

- 微内核架构：
- 
    这种架构中，核心系统提供最小的基础服务，而特定功能由插件组件提供 。

### 分布式架构包括：

- 服务为中心的架构：
  
将系统功能划分为多个服务，每个服务独立部署和管理 。

- 事件驱动架构：
  系统通过事件进行通信和处理，适合于实时处理和高并发场景 。
  
- 空间架构：
  
主要用于需要高可用性和可扩展性的场景 。

- 微服务架构：

将系统功能进一步细化为微小的、独立的服务单元，每个服务专注于特定业务功能 。

### 分布式架构的挑战与误区

分布式架构虽然提供了性能、可扩展性和高可用性方面的显著优势，但也带来了显著的复杂性和挑战。这些挑战包括分布式计算的八大误区，如网络可靠性、延迟、带宽、安全性等问题 。这些误区强调了架构师在设计分布式系统时必须充分考虑的关键因素，以避免系统中的潜在问题和陷阱。


## 第10章：分层架构样式

### 1. 分层架构的定义与重要性

分层架构，也称为n层架构，是一种将系统的不同功能按逻辑分层的架构风格。每一层负责特定的功能，比如表现逻辑或业务逻辑。这种架构风格因其简单性、熟悉性和低成本而成为大多数应用程序的标准选择​​。此外，根据康威定律，系统的设计会复制该组织的沟通结构，这也使得分层架构自然适用于多数企业应用​​。

### 2. 拓扑结构


<img width="698" alt="image" src="https://github.com/user-attachments/assets/3b2f3a95-210d-4086-a3a4-6253dd986d6a">


分层架构的组件被组织成水平的逻辑层，典型的有四层：表现层、业务层、持久层和数据库层。这些层的划分可以根据应用程序的复杂性进行调整，小型应用可能只有三层，而大型复杂的企业应用可能有五层或更多层​​。

表现层：负责处理用户界面和浏览器通信逻辑。它不需要关心数据的获取方式，只需显示数据即可。
业务层：负责执行与业务请求相关的特定业务规则。它从持久层获取数据，进行业务逻辑处理后传递给表现层。
持久层：管理数据库交互逻辑，通常包括查询、数据存储和检索等功能。
数据库层：实际存储数据的地方。
在实际部署时，这些层可以物理上分离成不同的部署单元，也可以组合成单个部署单元。对于小型应用程序，有时所有层甚至包含数据库层都会组合在一个部署单元中​​。

### 3. 分离关注点与职责模型

分层架构的一个关键概念是分离关注点，即每一层只处理与其相关的逻辑。例如，表现层只关心如何展示数据，而不关心数据的来源或如何处理；业务层则只关心业务逻辑的实现，而不涉及数据的展示​​。这种分离使得开发人员可以专注于各自领域的技术专长，提升了系统的模块化和职责清晰度。

### 4. 隔离层（Layers of Isolation）

每一层可以是关闭的或开放的。在关闭的层中，处理请求时不能跳过任何层，必须逐层向下传递；而在开放的层中，可以跳过中间层直接访问底层。这种设计使得各层之间具有独立性，降低了层之间的耦合​​。然而，过多的开放层可能导致系统的脆弱性和维护困难。

### 5. 添加新层

在某些情况下，添加新层可能是必要的。例如，为了限制表现层对业务对象的直接访问，可以引入一个服务层将这些对象隔离开来​​。这种层次的调整有助于明确系统中的访问限制和关系，从而避免紧耦合和脆弱的架构。

#### 6. 反模式和其他考虑因素

分层架构容易出现一种称为“架构陷阱”的反模式，即各层之间的请求仅仅是简单地传递，而没有实际的业务逻辑处理。这种情况会导致不必要的对象实例化和性能损失​​。此外，分层架构由于其单体性质，不利于大规模应用的扩展和性能优化。尽管可以通过缓存、多线程等技术提升性能，但这并非分层架构的固有特性​​。

### 7. 使用分层架构的理由
分层架构非常适合小型、简单的应用或网站。由于其简单性和开发人员的熟悉性，分层架构在成本和开发效率上具有优势，特别是在预算和时间紧张的情况下​​。然而，对于大型应用程序，由于可维护性、灵活性、可测试性和可部署性较差，分层架构可能不如其他更模块化的架构风格合适​​。

### 8. 架构特性评分
分层架构在总体成本和简单性方面得分较高，但在部署、可测试性、弹性和扩展性方面得分较低。这种架构的单体特性导致了较高的部署风险和较长的恢复时间（MTTR），因此在可靠性方面也得分不高​​。总体来说，尽管分层架构在某些应用场景中非常有效，但其在处理复杂系统时的局限性也是显而易见的。

### 分层架构特性评分

| 特性       | 评分（星级）  |
| ---------- | ------------- |
| **总体成本**  | ★★★★★      |
| **简单性**    | ★★★★★      |
| **可部署性**  | ★☆☆☆☆      |
| **可测试性**  | ★★☆☆☆      |
| **可靠性**    | ★★★☆☆      |
| **可扩展性**  | ★☆☆☆☆      |
| **弹性**      | ★☆☆☆☆      |
| **性能**      | ★★☆☆☆      |
| **容错性**    | ★☆☆☆☆      |
| **可用性**    | ★★☆☆☆      |

分层架构在总体成本和简单性方面得很好，但在部署、可测试性、弹性和扩展性方面较低。单体特性导致了较高的部署风险和较长的恢复时间（MTTR）。


### 第11章 管道架构

### 管道架构的定义与概述

管道架构是一种将功能划分为独立处理单元（称为过滤器）的模式，这些过滤器通过单向通信的管道连接在一起。这个模式的基本思想是将数据流的每个处理步骤封装在独立的过滤器中，这些过滤器依次处理数据流，最终将数据输出到终点。管道架构广泛应用于Unix终端shell语言（如Bash和Zsh）以及MapReduce编程模型中，展示了其强大的组合复用能力​​。

### 拓扑结构

管道架构的拓扑结构主要由两部分组成：管道和过滤器。

管道（Pipes）：在这个架构中，管道是过滤器之间的通信通道。每个管道通常是单向的，点对点传输（而非广播），以提高性能。管道承载的数据载荷可以是任何数据格式，但为了高性能，架构师倾向于使用较小的数据量​​。

过滤器（Filters）：过滤器是自包含的，独立于其他过滤器的单元，通常是无状态的。每个过滤器只执行一个任务，复杂的任务则通过多个过滤器的序列来处理​​。

### 过滤器类型

过滤器有四种基本类型：

生产者（Producer）：流程的起点，通常只出不进，有时也称为源头（Source）。

转换器（Transformer）：接受输入，可选地对部分或全部数据进行转换，然后将其发送到输出管道。函数式编程中的map操作类似于此类过滤器。

测试者（Tester）：接受输入，测试一个或多个条件，然后根据测试结果选择性地产生输出。函数式编程中的reduce操作类似于此类过滤器。

消费者（Consumer）：管道流程的终点。消费者有时会将最终结果持久化到数据库中，或者在用户界面上显示​​。

###  管道架构的特点与优势

组合复用性：由于管道和过滤器的单向性质和简单性，管道架构鼓励组合复用。开发者可以通过组合现有的过滤器和管道来创建新的数据处理流程​​。

模块化：管道架构中的每个过滤器都是独立的，可以单独修改或替换，而不影响其他过滤器。这种分离关注点的方式有助于提高系统的可维护性和可扩展性​​。

易于扩展：例如，在处理Kafka流数据的例子中，可以轻松地在Uptime Filter之后添加新的测试过滤器，以处理其他新的指标​​。

示例应用

管道架构模式在各种应用中都有体现，特别是那些涉及简单的单向数据处理任务。例如，许多电子数据交换（EDI）工具使用这种模式来转换文档类型；ETL工具（提取、转换和加载）利用管道架构将数据从一个数据库或数据源流向另一个；Apache Camel等编排器和中介者利用管道架构在业务流程的各个步骤之间传递信息​​。



### 管道架构特性评分

| 特性          | 评分（星级）  |
| ------------- | ------------- |
| **总体成本**    | ★★★★☆       |
| **简单性**      | ★★★★☆       |
| **可部署性**    | ★★★☆☆       |
| **可测试性**    | ★★★☆☆       |
| **可靠性**      | ★★★☆☆       |
| **可扩展性**    | ★☆☆☆☆       |
| **弹性**        | ★☆☆☆☆       |
| **性能**        | ★★☆☆☆       |
| **容错性**      | ★☆☆☆☆       |
| **可用性**      | ★★☆☆☆       |


管道架构在成本、简单性和模块化方面表现突出，但在可部署性、可测试性、弹性和可扩展性方面得分较低。这是因为尽管管道架构通过过滤器的独立性实现了一定程度的模块化，但它通常以单体部署为基础，带来了与分布式架构相比的复杂性和部署风险​​。特别是在应对高并发和大规模数据处理时，由于其单体特性，管道架构的扩展性受到限制​​。




